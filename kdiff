#!/bin/bash
set -euo pipefail

VERSION="0.1.0"
SCRIPT_NAME="kdiff"

YQ_EXPRESSION=""
DIFF_CMD=""
INTERNAL_MODE=0

# Help message
show_help() {
  cat << EOF
${SCRIPT_NAME} v${VERSION} - kubectl/argocd diff with yq pre-processing

USAGE:
    ${SCRIPT_NAME} [FLAGS] -- <COMMAND>

FLAGS:
    --yq                 yq expression to apply
    --diff-cmd           Command to use to perform the diff.
                         Defaults to KUBECTL_EXRTERNAL_DIFF
    --help               Show this help message

EXAMPLES:
    # Diff only deployment specs
    # All arguments after -- are passed to kubectl diff
    ${SCRIPT_NAME} --yq=.spec -- -f deployment.yaml

    # Remove noisy annotations before diffing
    ${SCRIPT_NAME} --yq 'del(.metadata.annotations."kubectl.kubernetes.io/last-applied-configuration")' -- kubectl diff -f .

INTEGRATION:
    Set as KUBECTL_EXTERNAL_DIFF for automatic usage:
    export KUBECTL_EXTERNAL_DIFF="${SCRIPT_NAME} --scope=.spec"
    kubectl diff -f myapp.yaml

EOF
}

# Parse command line arguments using GNU getopt
parse_args() {
  # Use getopt to parse and normalize arguments
  local PARSED
  if ! PARSED=$(getopt --options h --long help,yq:,diff-cmd: -n "${SCRIPT_NAME}" -- "$@"); then
    echo "Error: Unable to parse arguments: $@"  >&2
    exit 1
  fi

  # Set the normalized arguments
  eval set -- "${PARSED}"

  # Parse the normalized arguments
  while true; do
    case "$1" in
      -h|--help)
        show_help
        exit 0
        ;;
      --compare)
        INTERNAL_MODE=1
        shift
        ;;
      --yq)
        YQ_EXPRESSION="$2"
        shift 2
        ;;
      --diff-cmd)
        DIFF_CMD="$2"
        shift 2
        ;;
      --run)
        RUNTIME_DIR="$2"
        shift 2
        ;;
      --)
        shift
        break
        ;;
      *)
        echo "Unrecognized argument: $1" >&2
        ;;
    esac
  done

  # Store remaining arguments (file paths)
  KUBECTL_ARGS=("$@")
}

# Perform kubectl internal call
#
# Apply the yq transformation to left and right operands,
# and execute diff command on the result.
# The yq expression to use for preprocessing and the diff command are saved in a runtime directory,
# given as first argument.
# A staging area must be setup to avoid mangling the original files.#
# Arguments:
#   RUNTIME_DIR  The runtime directory with yq expression and diff command to use
#   LEFT         The left-hand side argument given by kubectl. Likely a directory
#   RIGHT        The right-hand side argument given by kubectl. Likely a directory
handle_internal_call() {
  :
}

# Setup ourselves as KUBECTL_EXTERNAL_DIFF and call kubectl
# We must save user-provided yq expression and diff command,
# because kubectl sanitizes KUBECTL_EXTERNAL_DIFF arguments.
#
# Arguments:
#   YQ_EXPR  The user-provided yq expression
#   DIFF_CMD The diff command to use
handle_interactive_call() {
  local yq_expr="$1"
  local diff_cmd="$2"
  local runtime_dir="$(create_runtime_dir)"
  populate_runtime_dir "${runtime_dir}" "${yq_expr}" "${diff_cmd}"
  KUBECTL_EXTERNAL_DIFF="kdiff --run ${runtime_dir##*/}" kubectl diff "${KUBECTL_ARGS[@]}"
}


# Resolve runtime directory path
#
# Given the runtime directory basename,
# locate it in XDG_RUNTIME_DIR,
# or as a debugging fallback in ${CWD}/run.
#
# Arguments:
#  RUNTIME_BASENAME  Base name of the runtime directory
#
# Output:
#   Absolute pathe the the runtime directory
resolve_runtime_dir {
  echo "${XDG_RUNTIME_DIR:-/tmp}"/"${1:-kdiff-run}"
}



# Apply yq transformation found in FILE
transform() {
  local yq_file="$1"
  local src="$2"
  local dest="${3:-${2/.yaml/.clean.yaml}}"

  # Build yq expression
  # TODO: See if yq supports reading script from a file
  local yq_expr
  if ! yq_expr="$(cat ${yq_file})"; then
    echo "Error: yq file ${yq_file} not found" >&2
    yq_expr='.'
  fi

  # Apply transformation
  if ! yq "${yq_expr}" "${src}" > "${dest}" 2>/dev/null; then
    echo "Error: yq transformation failed: ${yq_expr}" >&2
    exit 1
  fi
}

# Main function
main() {
  parse_args "$@"
  echo "INTERNAL_MODE=${INTERNAL_MODE}"
  echo "${KUBECTL_ARGS[@]"
}

# Run main function with all arguments
main "$@"
