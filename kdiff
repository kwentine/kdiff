#!/bin/bash
set -euo pipefail

# kdiff - Enhanced kubectl/argocd diff with filtering and preprocessing
# Usage: kdiff [FLAGS] -- <COMMAND>
#        kdiff --internal-diff-processor <file1> <file2>

VERSION="0.1.0"
SCRIPT_NAME="kdiff"

# Global variables for configuration
KIND_FILTER=""
SCOPE_FILTER=""
YQ_EXPRESSION=""
INTERNAL_MODE=false
ORIGINAL_EXTERNAL_DIFF=""

# Help message
show_help() {
    cat << EOF
${SCRIPT_NAME} v${VERSION} - Enhanced kubectl/argocd diff with filtering

USAGE:
    ${SCRIPT_NAME} [FLAGS] -- <COMMAND>

FLAGS:
    --kind=<kinds>        Only show diffs for specified resource kinds
                         (e.g., Pod,Service,po,svc). Case-insensitive.
    --scope=<yq_path>     Shortcut to diff only a specific part of resources
                         (e.g., .spec, .metadata.labels)
    --yq=<expression>     Apply arbitrary yq expression to both manifests
    --help               Show this help message

EXAMPLES:
    # Diff only deployment specs
    ${SCRIPT_NAME} --scope=.spec -- kubectl diff -f deployment.yaml
    
    # Show diffs for services and pods only
    ${SCRIPT_NAME} --kind=svc,po -- kubectl diff -k overlays/staging
    
    # Remove noisy annotations before diffing
    ${SCRIPT_NAME} --yq 'del(.metadata.annotations."kubectl.kubernetes.io/last-applied-configuration")' -- kubectl diff -f .
    
    # Use with argocd
    ${SCRIPT_NAME} --kind=Deployment -- argocd diff myapp

INTEGRATION:
    Set as KUBECTL_EXTERNAL_DIFF for automatic usage:
    export KUBECTL_EXTERNAL_DIFF="${SCRIPT_NAME} --scope=.spec"
    kubectl diff -f myapp.yaml

EOF
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            --help|-h)
                show_help
                exit 0
                ;;
            --kind=*)
                KIND_FILTER="${1#*=}"
                shift
                ;;
            --scope=*)
                SCOPE_FILTER="${1#*=}"
                shift
                ;;
            --yq=*)
                YQ_EXPRESSION="${1#*=}"
                shift
                ;;
            --compare)
                INTERNAL_MODE=true
                shift
                ;;
            --)
                shift
                break
                ;;
            *)
                # In internal mode, unknown arguments are file paths
                if [[ "${INTERNAL_MODE}" == true ]]; then
                    break
                else
                    echo "Error: Unknown option '$1'" >&2
                    echo "Use --help for usage information" >&2
                    exit 1
                fi
                ;;
        esac
    done
    
    # Store remaining arguments
    REMAINING_ARGS=("$@")
}

# Check dependencies
check_dependencies() {
    local missing_deps=()
    
    if ! command -v yq >/dev/null 2>&1; then
        missing_deps+=("yq")
    fi
    
    if ! command -v diff >/dev/null 2>&1; then
        missing_deps+=("diff")
    fi
    
    if ! command -v mktemp >/dev/null 2>&1; then
        missing_deps+=("mktemp")
    fi
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        echo "Error: Missing required dependencies: ${missing_deps[*]}" >&2
        echo "Please install the missing tools and try again." >&2
        exit 1
    fi
}

# Compare two files with filtering and transformations
compare_files() {
    local file1="$1"
    local file2="$2"
    
    # Validate input files exist
    if [[ ! -f "${file1}" ]]; then
        echo "Error: File not found: ${file1}" >&2
        exit 1
    fi
    if [[ ! -f "${file2}" ]]; then
        echo "Error: File not found: ${file2}" >&2
        exit 1
    fi
    
    # Step 1: Kind filtering
    if [[ -n "${KIND_FILTER}" ]]; then
        local resource_kind
        if resource_kind=$(yq '.kind' "${file1}" 2>/dev/null); then
            if ! should_include_kind "${resource_kind}"; then
                echo "INFO: Filtering out kind: ${resource_kind}" >&2
                exit 0  # Tell kubectl "no diff" for this resource
            fi
        else
            echo "Warning: Could not extract .kind from ${file1}" >&2
        fi
    fi
    
    # Step 2: Create temporary files for transformation
    local temp1 temp2
    temp1=$(mktemp "${TMPDIR:-/tmp}/kdiff.XXXXXX")
    temp2=$(mktemp "${TMPDIR:-/tmp}/kdiff.XXXXXX")
    
    # Setup cleanup trap
    trap 'rm -f "$temp1" "$temp2"' EXIT
    
    # Step 3: Apply transformations
    if ! apply_transformations "${file1}" "${temp1}"; then
        echo "Error: Failed to transform ${file1}" >&2
        exit 1
    fi
    
    if ! apply_transformations "${file2}" "${temp2}"; then
        echo "Error: Failed to transform ${file2}" >&2
        exit 1
    fi
    
    # Step 4: Run diff
    local diff_tool="${ORIGINAL_EXTERNAL_DIFF:-diff -u}"
    ${diff_tool} "${temp1}" "${temp2}"
    
    # Note: diff exit code is preserved (0=no diff, 1=diff found)
}

# Check if a resource kind should be included based on KIND_FILTER
should_include_kind() {
    local resource_kind="$1"
    
    if [[ -z "${KIND_FILTER}" ]]; then
        return 0  # No filter means include all
    fi
    
    # Convert to lowercase for case-insensitive comparison
    local kind_lower="${resource_kind,,}"
    local filter_lower="${KIND_FILTER,,}"
    
    # Split comma-separated kinds and check each
    IFS=',' read -ra kinds <<< "${filter_lower}"
    for kind in "${kinds[@]}"; do
        kind=$(echo "${kind}" | xargs)  # Trim whitespace
        
        # Check exact match or common abbreviations
        case "${kind_lower}" in
            "${kind}"|"${kind}s")  # Match exact or plural
                return 0
                ;;
            *)
                ;;
        esac
        
        # Check common Kubernetes abbreviations
        case "${kind}" in
            "po"|"pod")
                [[ "${kind_lower}" == "pod" ]] && return 0
                ;;
            "svc"|"service")
                [[ "${kind_lower}" == "service" ]] && return 0
                ;;
            "deploy"|"deployment")
                [[ "${kind_lower}" == "deployment" ]] && return 0
                ;;
            "cm"|"configmap")
                [[ "${kind_lower}" == "configmap" ]] && return 0
                ;;
            *)
                ;;
        esac
    done
    
    return 1  # Kind not found in filter
}

# Apply yq transformations to a file
apply_transformations() {
    local input_file="$1"
    local output_file="$2"
    
    # Build yq expression
    local yq_expr="."
    
    # Apply scope filter if specified
    if [[ -n "${SCOPE_FILTER}" ]]; then
        yq_expr="${SCOPE_FILTER}"
    fi
    
    # Apply custom yq expression if specified
    if [[ -n "${YQ_EXPRESSION}" ]]; then
        if [[ "${yq_expr}" == "." ]]; then
            yq_expr="${YQ_EXPRESSION}"
        else
            # Combine scope and custom expression
            yq_expr="${yq_expr} | ${YQ_EXPRESSION}"
        fi
    fi
    
    # Apply transformation
    if ! yq "${yq_expr}" "${input_file}" > "${output_file}" 2>/dev/null; then
        echo "Error: yq transformation failed: ${yq_expr}" >&2
        return 1
    fi
    
    return 0
}

# Main function
main() {
    parse_args "$@"
    check_dependencies
    
    if [[ "${INTERNAL_MODE}" == true ]]; then
        # Internal mode: called by kubectl with two file arguments
        if [[ ${#REMAINING_ARGS[@]} -lt 2 ]]; then
            echo "Error: Internal mode requires two file arguments" >&2
            exit 1
        fi
        
        compare_files "${REMAINING_ARGS[0]}" "${REMAINING_ARGS[1]}"
    else
        # User-facing mode: wrapper that sets up KUBECTL_EXTERNAL_DIFF
        if [[ ${#REMAINING_ARGS[@]} -eq 0 ]]; then
            echo "Error: No command specified after --" >&2
            echo "Use --help for usage information" >&2
            exit 1
        fi
        
        echo "User-facing mode not yet implemented" >&2
        echo "Would execute: ${REMAINING_ARGS[*]}" >&2
        echo "With filters: kind='${KIND_FILTER}' scope='${SCOPE_FILTER}' yq='${YQ_EXPRESSION}'" >&2
        exit 1
    fi
}

# Run main function with all arguments
main "$@"