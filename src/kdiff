#!/bin/bash
set -euo pipefail
shopt -s nullglob

VERSION="0.1.0"
SCRIPT_NAME="kdiff"

# Help message
show_help() {
  cat << EOF
${SCRIPT_NAME} v${VERSION} - Kubernetes diffs with pluggable pre-processing

USAGE:
    ${SCRIPT_NAME} [FLAGS] -- <COMMAND>

FLAGS:
    --yq                 yq expression to apply. A shorthand for --transform 'yq <expr>'
    --transform          Preprocessing command
    --compare            Comparison (diff) command
                         Defaults to KUBECTL_EXRTERNAL_DIFF
    --preset             Name of a preset to use. A matchin directory must exist in HOME/.config/kdiff
                         Alternatively, provide an absolute path to a preset directory, e.g. /tmp/test
    --help               Show this help message

EXAMPLES OF INTERACTIVE USE:
    # Diff only deployment specs
    # All arguments after -- are forwarded to kubectl diff
    # The value of KUBECTL_EXTERNAL_DIFF will be used as default compare tool
    ${SCRIPT_NAME} --yq=.spec -- -f deployment.yaml

    # Remove noisy fields
    ${SCRIPT_NAME} --yq 'del(.metadata.managedFields, .status)' -- -Rf .

    # Use with custom transform and compare commands
    ${SCRIPT_NAME} --transform 'kubectl neat -f -' --compare 'dyff between' -- -f deploy.yaml

    # Use presets.
    # Assuming that you have in HOME/.config/kdiff/diff-no-clutter:
    #   - An executable file named 'transform' accepting a yaml stream on stdin
    #   - An executable file name 'compare' accepting two argumens <left> and <right>
    # Then have kdiff use the combination by:
    ${SCRIPT_NAME} --preset diff-no-clutter -- -k overlays/production

INTEGRATION AS KUBECTL_EXTERNAL_DIFF:
    You can directly set kdiff as KUBECTL_EXTERNAL_DIFF.
    export KUBECTL_EXTERNAL_DIFF="${SCRIPT_NAME} --preset dyff-no-clutter"
    kubectl diff -f myapp.yaml
EOF
}


# Parse command line arguments using GNU getopt
parse_args() {

  if ! command -v getopt >/dev/null; then
        echo "Error: GNU getopt is required but not found" >&2
        exit 1
  fi

  local opts
  if ! opts=$(getopt --options h,y,c,t,p --long help,yq:,compare:,transform:,preset: -n "${SCRIPT_NAME}" -- "$@"); then
    echo "Error: Unable to parse arguments: $@"  >&2
    exit 1
  fi

  # Set the normalized arguments
  eval set -- "${opts}"

  # Parse the normalized arguments
  while true; do
    case "$1" in
      '-h'|'--help')
        show_help
        exit 0
        ;;
      '-y'|'--yq')
        yq_expr="$2"
        shift 2
        ;;
      '-t'|'--transform')
        transform="$2"
        shift 2
        ;;
      '-c'|'--compare')
        compare="$2"
        shift 2
        ;;
      '-p'|'--preset')
        preset="$2"
        shift 2
        ;;
      '--')
        shift
        break
        ;;
      *)
        echo "Unrecognized argument: $1" >&2
        ;;
    esac
  done

  echo "Debug: remaning args: $@"
  # If we have exactly 2 non-option arguments,
  # both of which either files or directories,
  # then we are called as KUBECTL_EXTERNAL_DIFF

  # TODO There must be a more concise way...
  if (($# == 2)); then
    if [[ -f "$1" ]] && [[ -f "$2" ]]; then
      echo "Debug: called by argocd diff" >&2
      compare_files=1
    elif [[ -d "$1" ]] && [[ -d "$2" ]]; then
      echo "Debug: called by kubectl diff" >&2
      compare_dirs=1
    fi
  fi
  ((interactive = compare_files || compare_dirs))
  # Store remaining arguments (file paths)
  # TODO Rename to remaining_args or remove variable altogether ?
  kubectl_args=("$@")
}

# Perform kubectl internal call
#
# This function is executed by kubectl/argocd. It receives two paths to compare.
# It relies on a preset (created by a prior interactive call) to provide the
# actual transform and compare commands.
#
# Arguments:
#   LEFT         The left-hand side argument given by the diff tool.
#   RIGHT        The right-hand side argument given by the diff tool.
handle_internal_call() {
  echo "Debug: Internal call with args: $@" >&2

  # An internal call MUST have a preset argument.
  if [[ -z "${preset}" ]]; then
    echo "Error: Internal call is missing the required --preset argument." >&2
    exit 1
  fi

  # These variables will be populated by load_presets.
  # TODO should be renamed to transform_exec and compare_exec
  local transform_cmd=""
  local compare_cmd=""
  load_presets "${preset}"

  local left="$1"
  local right="$2"

  # Create staging directories for the transformed files.
  local left_staged
  left_staged=$(create_staging_dir)
  local right_staged
  right_staged=$(create_staging_dir)

  # Stage the files, applying transformations.
  stage_all "${left}" "${left_staged}" "${transform_cmd}"
  stage_all "${right}" "${right_staged}" "${transform_cmd}"

  # Execute the compare command from the preset.
  # The load_presets function guarantees that this command exists and is executable.
  if ((compare_dirs)); then
    # Pass staging directories directly to compare command.
    # Files in both directories are assumed to have matching names.
    "${compare_cmd}" "${left_staged}" "${right_staged}"
  elif ((compare_files)); then
    # Pass individual transformed files to compare command.
    # Ensure a single file comes from each directory after glob expansion
    left_file=("${left_staged}"/*)
    right_file=("${right_staged}"/*)
    if (( ${#left_file[@]} != 1 || ${#right_file[@]} != 1 )); then
      echo "Error: Expected exactly one file in each staging directory, found ${#left_file[@]} and ${#right_file[@]}" >&2
      exit 2
    fi
    "${compare_cmd}" "${left_file[0]}" "${right_file[0]}"
  else
    echo "Error: we are supposed to compare either two files or two directories" >&2
    # TODO We should ensure error codes > 1 are returned upond abnormal termination
    #      to distinguish from 1 returned by diff tool on difference found
    exit 2
  fi
}

# Setup ourselves as KUBECTL_EXTERNAL_DIFF and call kubectl
# We must save user-provided yq expression and diff command,
# because kubectl sanitizes KUBECTL_EXTERNAL_DIFF arguments.
#
# Example of an interactive call
#   kdiff --yq='del(.metadata.annotations) --diff-cmd='dyff' -- -f mypod.yaml
#
# Arguments:
#   YQ_EXPR  The user-provided yq expression
#   DIFF_CMD The diff command to use
handle_interactive_call() {
  echo "Debug: Interactive call with args: $@" >&2

  local preset_name
  if [[ -n "${preset}" ]]; then
    # If a preset is specified, use it directly.
    preset_name="${preset}"
  else
    # Otherwise, create a runtime preset for the ad-hoc transform/compare flags.
    preset_name=$(create_runtime_preset)
  fi

  # Get the absolute path of the currently running script
  local script_path
  script_path=$(readlink -f "$0")

  export KUBECTL_EXTERNAL_DIFF="${script_path} --preset ${preset_name}"

  # Unset variables that might interfere with the internal call
  unset yq_expr transform compare preset

  kubectl diff "${kubectl_args[@]}"
}


# Transform a file prior to comparison
# Apply transform and save the output with the same basename,
# in the staging directory
transform() {
    local src_file="$1"
    local staging_dir="$2"
    local transform_exec="$3"

    # Skip if the source is not a file
    [[ ! -f "${src_file}" ]] && return

    local basename
    basename=$(basename "${src_file}")
    local dest_file="${staging_dir}/${basename}"

    if [[ -n "${transform_exec}" && -x "${transform_exec}" ]]; then
      if ! "${transform_exec}" < "${src_file}" > "${dest_file}"; then
        echo "Warning: Transform failed for ${basename}, using original" >&2
        cp "${src_file}" "${dest_file}"
      fi
    else
      # If no transform, just copy the file
      cp "${src_file}" "${dest_file}"
    fi
}


# Stage file, or all files in a directory, by delegating to stage_file
#
# We don't know if the argument passed by the upstream tool will be a file or a directory.
# kubectl passes a directory with all files to diff inside; argocd diff passes a single file.
stage_all() {
    local src_path="$1"
    local staging_dir="$2"
    local transform_cmd="$3"

    mkdir -p "${staging_dir}"

    if [[ -d "${src_path}" ]]; then
      # If it's a directory, process all files within it
      local file
      for file in "${src_path}"/*; do
        transform "${file}" "${staging_dir}" "${transform_cmd}"
      done
    elif [[ -f "${src_path}" ]]; then
      # If it's a single file, process it
      transform "${src_path}" "${staging_dir}" "${transform_cmd}"
    else
        echo "Error: Path is neither a file nor a directory: ${src_path}" >&2
        return 1
    fi
}


# Load a preset given by name
# We need to resolve the name relative to runtime or configuration directory.
# It is not possible to give an absolute path,
# because this would not pass kubectl argument sanitization.
# Sets the variables transform_cmd and compare_cmd to absolute executable paths
load_presets() {
  local preset_name="$1"
  local preset_dir=""

  # User configuration takes precedence
  if [[ -d "${config_dir}/${preset_name}" ]]; then
    preset_dir="${config_dir}/${preset_name}"
  elif [[ -d "${runtime_dir}/${preset_name}" ]]; then
    preset_dir="${runtime_dir}/${preset_name}"
  else
    echo "Error: Preset '${preset_name}' not found in ${config_dir} or ${runtime_dir}" >&2
    exit 1
  fi

  if [[ ! -d "${preset_dir}" ]]; then
    echo "Error: Preset directory not found: ${preset_dir}" >&2
    exit 1
  fi

  transform_cmd="${preset_dir}/transform"
  if [[ ! -x "${transform_cmd}" ]]; then
    echo "Error: Preset transform command is not executable or does not exist: ${transform_cmd}" >&2
    exit 1
  fi

  compare_cmd="${preset_dir}/compare"
  if [[ ! -x "${compare_cmd}" ]]; then
    echo "Error: Preset compare command is not executable or does not exist: ${compare_cmd}" >&2
    exit 1
  fi
}

# Create the staging directory where we store the transformed files prior to comparison
create_staging_dir() {
  local staging_dir
  staging_dir=$(mktemp -d -t kdiff-staging-XXXXXX)
  staging_dirs+=("${staging_dir}")
  echo "${staging_dir}"
}


cleanup_staging_dirs() {
  for dir in "${staging_dirs[@]}"; do
    [[ -d "${dir}" ]] && rm -rf "${dir}"
  done
}


# Create a default runtime preset directory, capturing the interactive call arguments.
# TODO: How do we cleanup all these runtime directories ?
create_runtime_preset() {
  local preset_name="preset-$$"
  local preset_dir="${runtime_dir}/${preset_name}"

  mkdir -p "${preset_dir}"

  compile_transform "${preset_dir}" "${yq_expr}"
  compile_compare "${preset_dir}"

  echo "${preset_name}"
}

# Save transform command to runtime preset
# The --transform command line argument takes precedence over --yq
# Fall back to cat
compile_transform() {
  local preset_dir="${1}"
  local yq_expr="${2}"
  local transform_script_path="${preset_dir}/transform"

  # Start with cat as the base command
  local cmd="cat -"

  # --yq sets a yq expression
  if [[ -n "${yq_expr}" ]]; then
    # Use printf to properly quote the expression
    cmd=$(printf 'yq %q' "${yq_expr}")
  fi

  # --transform overrides --yq
  if [[ -n "${transform}" ]]; then
    cmd="${transform}"
  fi

  cat <<EOF > "${transform_script_path}"
#!/bin/bash
set -euo pipefail
${cmd}
EOF

  chmod +x "${transform_script_path}"
}

# Save compare command to runtime preset
# The --compare command line argument takes precedence
# Fall back to KUBECTL_EXTERNAL_DIFF if set, otherwise good'ol diff
compile_compare() {
  local preset_dir="${1}"
  local compare_script_path="${preset_dir}/compare"

  # Start with diff as the base command
  local cmd="diff -u"

  # KUBECTL_EXTERNAL_DIFF is the default if set
  if [[ -n "${KUBECTL_EXTERNAL_DIFF:-}" ]]; then
    cmd="${KUBECTL_EXTERNAL_DIFF}"
  fi

  # --compare overrides everything
  if [[ -n "${compare}" ]]; then
    cmd="${compare}"
  fi

  cat <<EOF > "${compare_script_path}"
#!/bin/bash
set -euo pipefail
${cmd} "\$@"
EOF

  chmod +x "${compare_script_path}"
}

# Main function
main() {
  # TODO Should we use a convention to cleary identify these "semi global"
  #      variables that hold shared state several functions rely on ?
  # Setup defaults
  local yq_expr=""
  # TODO compare_cmd and transform_cmd would perhaps be better names
  #      see similar variables initialized in load_preset
  local compare=""
  local transform=""
  local preset=""
  # Whether we are passed two files or two directories to compare
  local compare_files=0
  local compare_dirs=0
  # Are we acting as KUBECTL_EXTERNAL_DIFF and called by kubectl,
  # or called by the user directly as kdiff ?
  local interactive=0

  # TODO These should be proper environment variables
  local runtime_dir="${XDG_RUNTIME_DIR:-/tmp}/kdiff"
  local config_dir="${XDG_CONFIG_HOME:-${HOME}/.config/kdiff}"

  # TODO Name should be more general: remaining_args or not_our_args
  local kubectl_args=()
  local staging_dirs=()
  trap 'cleanup_staging_dirs' EXIT INT TERM

  parse_args "$@"

  if [[ "${interactive}" -eq 1 ]]; then
    handle_interactive_call
  else
    # The arguments for the internal call are the paths left by parse_args
    handle_internal_call "${kubectl_args[@]}"
  fi
}

# Run main function with all arguments
main "$@"
