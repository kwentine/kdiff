#!/bin/bash
set -euo pipefail
shopt -s nullglob

VERSION="0.1.0"
SCRIPT_NAME="kdiff"

[[ -z "${KDIFF_RUNTIME_DIR:-}" ]] && KDIFF_RUNTIME_DIR="${XDG_RUNTIME_DIR:-/tmp}/kdiff"
[[ -z "${KDIFF_CONFIG_DIR:-}" ]] && KDIFF_CONFIG_DIR="${XDG_CONFIG_HOME:-${HOME}/.config}/kdiff"

# We use the same convention as diff:
#   Exit status is 0 if inputs are the same, 1 if different, 2 if trouble.
readonly SUCCESS=0
readonly DIFFERENT=1
readonly ERROR=2

debug() {
  [[ "${KDIFF_DEBUG:-}" == "1" ]] && echo "DEBUG: $*" >&2
  return 0
}

error_exit() {
  echo "ERROR: $*" >&2
  exit "${ERROR}"
}

# Help message
show_help() {
  cat << EOF
${SCRIPT_NAME} v${VERSION} - Kubernetes diffs with pluggable pre-processing

USAGE:
    ${SCRIPT_NAME} [FLAGS] -- <COMMAND>

FLAGS:
    --yq                 yq expression to apply. A shorthand for --transform 'yq <expr>'
    --transform          Preprocessing command
    --compare            Comparison (diff) command
                         Defaults to KUBECTL_EXRTERNAL_DIFF
    --preset             Name of a preset to use. A matching directory must exist in HOME/.config/kdiff
                         Alternatively, provide an absolute path to a preset directory, e.g. /tmp/test
    --help               Show this help message

EXAMPLES OF INTERACTIVE USE:
    # Diff only deployment specs
    # All arguments after -- are forwarded to kubectl diff
    # The value of KUBECTL_EXTERNAL_DIFF will be used as default compare tool
    ${SCRIPT_NAME} --yq=.spec -- -f deployment.yaml

    # Remove noisy fields
    ${SCRIPT_NAME} --yq 'del(.metadata.managedFields, .status)' -- -Rf .

    # Use with custom transform and compare commands
    ${SCRIPT_NAME} --transform 'kubectl neat -f -' --compare 'dyff between' -- -f deploy.yaml

    # Use presets.
    # Assuming that you have in HOME/.config/kdiff/diff-no-clutter:
    #   - An executable file named 'transform' accepting a yaml stream on stdin
    #   - An executable file name 'compare' accepting two argumens <left> and <right>
    # Then have kdiff use the combination by:
    ${SCRIPT_NAME} --preset diff-no-clutter -- -k overlays/production

INTEGRATION AS KUBECTL_EXTERNAL_DIFF:
    You can directly set kdiff as KUBECTL_EXTERNAL_DIFF.
    export KUBECTL_EXTERNAL_DIFF="${SCRIPT_NAME} --preset dyff-no-clutter"
    kubectl diff -f myapp.yaml
EOF
}


# Parse command line arguments using GNU getopt
parse_args() {

  if ! command -v getopt >/dev/null; then
        error_exit "GNU getopt is required but not found"
  fi

  local opts
  if ! opts=$(getopt --options h,y,c,t,p --long help,yq:,compare:,transform:,preset: -n "${SCRIPT_NAME}" -- "$@"); then
    error_exit "Unable to parse arguments: $*"
  fi

  # Set the normalized arguments
  eval set -- "${opts}"

  # Parse the normalized arguments
  while true; do
    case "$1" in
      '-h'|'--help')
        show_help
        exit 0
        ;;
      '-y'|'--yq')
        yq_expr="$2"
        shift 2
        ;;
      '-t'|'--transform')
        transform_cmd="$2"
        shift 2
        ;;
      '-c'|'--compare')
        compare_cmd="$2"
        shift 2
        ;;
      '-p'|'--preset')
        preset="$2"
        shift 2
        ;;
      '--')
        shift
        break
        ;;
      *)
        error_exit "Unrecognized argument: $1"
        ;;
    esac
  done

  debug "Remaining args: $*"
  # If we have exactly 2 non-option arguments,
  # both of which either files or directories,
  # then we are called as KUBECTL_EXTERNAL_DIFF
  # TODO we are called internally but files do not exist ?
  if (($# == 2)); then
    if [[ -f "$1" ]] && [[ -f "$2" ]]; then
      compare_files=1
    elif [[ -d "$1" ]] && [[ -d "$2" ]]; then
      compare_dirs=1
    fi
  fi
  internal_call=$((compare_files || compare_dirs))
  remaining_args=("$@")
}

# Perform kubectl internal call
#
# This function is executed by kubectl/argocd. It receives two paths to compare.
# It relies on a preset (created by a prior interactive call) to provide the
# actual transform and compare commands.
#
# Arguments:
#   LEFT         The left-hand side argument given by the diff tool.
#   RIGHT        The right-hand side argument given by the diff tool.
handle_internal_call() {
  debug "Internal call with left=${1} and right=${2}"

  if [[ -z "${preset:-}" ]]; then
    debug "Using default preset (--preset argument not given)"
    preset=default
  fi

  # These variables will be populated by load_preset.
  local transform_exec compare_exec
  load_preset "${preset}"

  local left="$1"
  local right="$2"

  # Create staging directories for the transformed files.
  local left_staged
  left_staged=$(create_staging_dir)
  local right_staged
  right_staged=$(create_staging_dir)

  # Stage the files, applying transformations.
  stage_all "${left}" "${left_staged}" "${transform_exec}"
  stage_all "${right}" "${right_staged}" "${transform_exec}"

  # Execute the compare command from the preset.
  # The load_preset function guarantees that this command exists and is executable.
  if ((compare_dirs)); then
    # Pass staging directories directly to compare command.
    # Files in both directories are assumed to have matching names.
    "${compare_exec}" "${left_staged}" "${right_staged}"
  elif ((compare_files)); then
    # Pass individual transformed files to compare command.
    # Ensure a single file comes from each directory after glob expansion
    left_file=("${left_staged}"/*)
    right_file=("${right_staged}"/*)
    if (( ${#left_file[@]} != 1 || ${#right_file[@]} != 1 )); then
      echo "Error: Expected exactly one file in each staging directory, found ${#left_file[@]} and ${#right_file[@]}" >&2
      exit 2
    fi
    "${compare_exec}" "${left_file[0]}" "${right_file[0]}"
  else
    echo "Error: we are supposed to compare either two files or two directories" >&2
    # TODO We should ensure error codes > 1 are returned upond abnormal termination
    #      to distinguish from 1 returned by diff tool on difference found
    exit 2
  fi
}

# Setup ourselves as KUBECTL_EXTERNAL_DIFF and call kubectl
# We must save user-provided yq expression and diff command,
# because kubectl sanitizes KUBECTL_EXTERNAL_DIFF arguments.
#
# Example of an interactive call
#   kdiff --yq='del(.metadata.annotations) --diff-cmd='dyff' -- -f mypod.yaml
#
# Arguments:
#   YQ_EXPR  The user-provided yq expression
#   DIFF_CMD The diff command to use
handle_interactive_call() {
  debug "Interactive call with args: ${remaining_args[*]}"

  local preset_name
  preset_name=$(create_runtime_preset)

  # Get the absolute path of the currently running script
  local script_path
  script_path=$(readlink -f "$0")

  export KUBECTL_EXTERNAL_DIFF="${script_path} --preset ${preset_name}"

  # Unset variables that might interfere with the internal call
  unset yq_expr transform_cmd compare_cmd preset

  kubectl diff "${remaining_args[@]}"
}


# Transform a file prior to comparison
# Apply transform and save the output with the same basename,
# in the staging directory
transform() {
    local src_file="$1"
    local staging_dir="$2"
    local transform_exec="$3"

    # Skip if the source is not a file
    [[ ! -f "${src_file}" ]] && return

    local basename
    basename=$(basename "${src_file}")
    local dest_file="${staging_dir}/${basename}"

    if [[ -n "${transform_exec}" && -x "${transform_exec}" ]]; then
      if ! "${transform_exec}" < "${src_file}" > "${dest_file}"; then
        echo "Warning: Transform failed for ${basename}, using original" >&2
        cp "${src_file}" "${dest_file}"
      fi
    else
      # If no transform, just copy the file
      cp "${src_file}" "${dest_file}"
    fi
}


# Stage file, or all files in a directory, by delegating to stage_file
#
# We don't know if the argument passed by the upstream tool will be a file or a directory.
# kubectl passes a directory with all files to diff inside; argocd diff passes a single file.
stage_all() {
    local src_path="$1"
    local staging_dir="$2"
    local transform_exec="$3"

    mkdir -p "${staging_dir}"

    if [[ -d "${src_path}" ]]; then
      # If it's a directory, process all files within it
      local file
      for file in "${src_path}"/*; do
        transform "${file}" "${staging_dir}" "${transform_exec}"
      done
    elif [[ -f "${src_path}" ]]; then
      # If it's a single file, process it
      transform "${src_path}" "${staging_dir}" "${transform_exec}"
    else
        echo "Error: Path is neither a file nor a directory: ${src_path}" >&2
        return 1
    fi
}


# Load transform and compare executables specified by a preset.
# A preset is either:
#   - a string of the form '<transform>:<compare>'
#   - an alias to a file containing such a string
# Components of the spec refer to executable files,
# found either in KDIFF_CONFIG_DIR or KDIFF_RUNTIME_DIR,
# saved in 'transform_exec' and 'compare_exec' respectively.
load_preset() {
  local spec="$1"
  local maybe_transform_exec
  local maybe_compare_exec
  local transform compare

  debug "Loading preset ${spec}"

  for preset_dir in "${KDIFF_CONFIG_DIR}" "${KDIFF_RUNTIME_DIR}"; do

    # If an alias file exists in the current directory,
    # use its content as our preset spec.
    if [[ -f "${preset_dir}/${spec}" ]]; then
      spec=$(cat "${preset_dir}/${spec}")
      debug "Resolve alias to ${spec}"
    fi

    # The preset spec by now must be of the form: <transform>:<compare>
    # If not, try the next directory in line.
    if ! [[ ${spec} = *:* ]]; then
      continue
    fi

    IFS=':' read -r transform compare <<< "${spec}"

    # Construct the full paths for the transform and compare scripts.
    # TODO: Ensure default executables are installed (cat and diff)
    maybe_transform_exec="${preset_dir}/transform/${transform:-default}"
    maybe_compare_exec="${preset_dir}/compare/${compare:-default}"

    # Check if a *complete* preset (both parts executable) exists in this directory.
    if [[ -x "${maybe_transform_exec}" && -x "${maybe_compare_exec}" ]]; then
      # Success! We found a valid preset. Set the global vars and exit.
      transform_exec="${maybe_transform_exec}"
      compare_exec="${maybe_compare_exec}"
      return 0
    fi
  done

  # If the loop finishes, no valid preset was found in any directory.
  error_exit "Could not find a valid preset for '${1}' in ${KDIFF_CONFIG_DIR} or ${KDIFF_RUNTIME_DIR}"
}

# Create the staging directory where we store the transformed files prior to comparison
create_staging_dir() {
  local staging_dir
  staging_dir=$(mktemp -d -t kdiff-staging-XXXXXX)
  staging_dirs+=("${staging_dir}")
  echo "${staging_dir}"
}


cleanup_staging_dirs() {
  for dir in "${staging_dirs[@]}"; do
    [[ -d "${dir}" ]] && rm -rf "${dir}"
  done
}

# Create runtime preset from the interactive call arguments.
create_runtime_preset() {
  local transform_exec compare_exec alias spec

  if [[ -n "${preset:-}"  ]]; then
    echo "${preset}"
    return
  fi

  mkdir -p "${KDIFF_RUNTIME_DIR}"
  transform_exec=$(compile_transform)
  compare_exec=$(compile_compare)
  local spec="${transform_exec}:${compare_exec}"
  local alias="${spec/:/-}"
  if [[ ! -f "${KDIFF_RUNTIME_DIR}/${alias}" ]]; then
    echo "${spec}" > "${KDIFF_RUNTIME_DIR}/${alias}"
  else
    touch "${KDIFF_RUNTIME_DIR}/${alias}"
  fi
  echo "${alias}"
}

# Saves a command in an executatble file, named by its content hash.
# Arguments:
#   CMD        String containing the command
#   DEST_DIR   Directory where the executable file should be saved.
#              Created if it does not already exists.
# TODO: Brainstorm alternative names: create_exec_file, save_exec_file...
save_cmd() {
  local cmd="${1}"
  local exec_dir="${2}"
  mkdir -p "${exec_dir}"
  content="#!/bin/bash
set -euo pipefail
${1} \"\$@\"
"
  exec_name="$(printf '%s' "${content}" | sha1sum | head -c 8)"
  local exec_path="${exec_dir}/${exec_name}"

  if [[ -x "${exec_path}" ]]; then
    # May help for bookeeping and cleanup
    touch "${exec_path}"
  else
    echo "${content}" > "${exec_path}"
    chmod +x "${exec_path}"
  fi
  echo "${exec_name}"
}

# Save transform command to an executable file in the runtime preset directory.
# Name the file with an abridged hash of its contents.
# The --transform command line argument takes precedence over --yq
# Fall back to cat
compile_transform() {
  # Start with cat as the base command
  local cmd="cat -"
  # --transform takes precedence over --yq
  if [[ -n "${transform_cmd:-}" ]]; then
    cmd="${transform_cmd}"
  elif [[ -n "${yq_expr:-}" ]]; then
    cmd=$(printf 'yq %q' "${yq_expr}")
  fi
  save_cmd "${cmd}" "${KDIFF_RUNTIME_DIR}/transform"
}

# Save compare command to runtime preset
# The --compare command line argument takes precedence
# Fall back to KUBECTL_EXTERNAL_DIFF if set, otherwise good'ol diff
compile_compare() {
  local cmd
  # Try --compare
  if [[ -n "${compare_cmd:-}" ]]; then
    cmd="${compare_cmd}"
  elif [[ -n "${KUBECTL_EXTERNAL_DIFF:-}" ]]; then
    # TODO: Double check that KUBECTL_EXTERNAL_DIF="kdiff --preset foo:bar" would not break
    #       I think it would have the effect of composing the transforms
    cmd="${KUBECTL_EXTERNAL_DIFF}"
  else
    cmd="diff -u"
  fi
  save_cmd "${cmd}" "${KDIFF_RUNTIME_DIR}/compare"
}

# Main function
main() {
  # TODO Should we use a convention to cleary identify these "semi global"
  #      variables that hold shared state several functions rely on ?

  # Setup defaults
  local yq_expr=""

  local compare_cmd transform_cmd
  local preset

  # Whether we are passed two files or two directories to compare
  local compare_files=0
  local compare_dirs=0

  # Are we acting as KUBECTL_EXTERNAL_DIFF and called by kubectl,
  # or called by the user directly as kdiff ?
  local internal_call=0

  local staging_dirs=()
  trap 'cleanup_staging_dirs' EXIT INT TERM

  local remaining_args=()
  parse_args "$@"

  if ((internal_call)); then
    # The arguments for the internal call are the paths left by parse_args
    handle_internal_call "${remaining_args[@]}"
  else
    handle_interactive_call
  fi
}

# Run main function with all arguments
main "$@"
